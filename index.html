<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rain Window - 水滴が流れる窓</title>

    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 50%, #6c5ce7 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(2px);
        }
        
        .title {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
            pointer-events: none;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            z-index: 10;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="title">雨の窓 - Rain Window</div>
    <div class="instructions">
        クリック: 水滴を追加 | Rキー: リセット
    </div>

    <script>
        let canvas, ctx;
        let drops = [];
        let trailResidues = []; // 水滴の軌跡に残る小さな水の粒
        let gravity = 0.2;
        let maxDrops = 100;
        let animationId;

        // ユーティリティ関数
        function random(min, max) {
            if (max === undefined) {
                max = min;
                min = 0;
            }
            return Math.random() * (max - min) + min;
        }

        function map(value, start1, stop1, start2, stop2) {
            return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
        }

        function dist(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }

        function constrain(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        class TrailResidue {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.opacity = random(0.2, 0.6);
                this.life = random(200, 400); // フレーム数での寿命
                this.maxLife = this.life;
                this.fadeSpeed = random(0.005, 0.01);
            }
            
            update() {
                this.life--;
                // より自然なフェードアウト
                let fadeRatio = this.life / this.maxLife;
                this.opacity = fadeRatio * random(0.2, 0.6);
            }
            
            display() {
                if (this.life <= 0) return;
                
                // メインの残留水滴
                ctx.globalAlpha = this.opacity;
                ctx.fillStyle = `rgba(255, 255, 255, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 非常に小さなハイライト（半径が0.8以上の場合のみ）
                if (this.radius >= 0.8) {
                    ctx.globalAlpha = this.opacity * 0.7;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(this.x - this.radius * 0.4, this.y - this.radius * 0.4, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            isDead() {
                return this.life <= 0;
            }
        }

        class Droplet {
            constructor(x, y, radius = null) {
                this.x = x;
                this.y = y;
                this.radius = radius || random(3, 12);
                this.velocity = 0;
                this.acceleration = gravity;
                this.opacity = random(0.6, 0.9);
                this.trail = [];
                this.maxTrailLength = 8;
                this.merged = false;
                
                // 形状のパラメータ
                this.shape = {
                    distortionX: random(0.8, 1.2), // 横方向の歪み
                    distortionY: random(0.9, 1.1), // 縦方向の歪み
                    asymmetry: random(-0.1, 0.1), // 左右の非対称性
                    flattenFactor: 0 // 表面への平坦化度合い
                };
            }

            update() {
                // 重力による加速
                this.velocity += this.acceleration;
                this.velocity = Math.min(this.velocity, this.radius * 0.5);
                
                // 位置更新
                this.y += this.velocity;
                
                // 速度に基づく形状の更新
                this.updateShape();
                
                // トレイル（軌跡）の更新
                this.trail.push({x: this.x, y: this.y, r: this.radius * 0.5});
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // 大きな水滴の場合、軌跡に小さな水を残す（より頻繁に、より現実的な配置で）
                if (this.radius > 5 && Math.random() < 0.4) {
                    let residueRadius = random(0.8, this.radius * 0.25);
                    let offsetX = random(-this.radius * 0.4, this.radius * 0.4);
                    trailResidues.push(new TrailResidue(
                        this.x + offsetX, 
                        this.y + random(-2, 2), 
                        residueRadius
                    ));
                }
                
                // 中程度の水滴も時々小さな残留物を残す
                if (this.radius > 3 && this.radius <= 5 && Math.random() < 0.15) {
                    let residueRadius = random(0.5, 1.5);
                    trailResidues.push(new TrailResidue(
                        this.x + random(-this.radius * 0.3, this.radius * 0.3), 
                        this.y, 
                        residueRadius
                    ));
                }
                
                // 大きな水滴は少し横に揺れる
                if (this.radius > 8) {
                    this.x += Math.sin(this.y * 0.01) * 0.3;
                }
            }

            updateShape() {
                // 速度に基づく縦方向の伸長（ティアドロップ効果）
                if (this.velocity > 1.5) {
                    // 高速時：強いティアドロップ効果
                    this.shape.distortionY = 1 + (this.velocity * 0.25);
                    this.shape.distortionX = Math.max(0.6, 1 - (this.velocity * 0.12));
                } else if (this.velocity > 0.5) {
                    // 中速時：軽いティアドロップ効果
                    this.shape.distortionY = 1 + (this.velocity * 0.15);
                    this.shape.distortionX = Math.max(0.75, 1 - (this.velocity * 0.08));
                } else {
                    // 静止または低速時は表面に平たくなる
                    this.shape.distortionY = random(0.8, 1.0);
                    this.shape.distortionX = random(1.1, 1.35);
                    this.shape.flattenFactor = random(0.15, 0.35);
                }
                
                // サイズに基づく歪み（大きな水滴ほど重力で変形）
                if (this.radius > 8) {
                    this.shape.distortionY += 0.15;
                    this.shape.asymmetry = random(-0.2, 0.2);
                } else if (this.radius > 5) {
                    this.shape.distortionY += 0.05;
                    this.shape.asymmetry = random(-0.1, 0.1);
                }
                
                // 微妙な揺らぎ効果
                this.shape.distortionX += random(-0.05, 0.05);
                this.shape.distortionY += random(-0.03, 0.03);
            }

            // 現実的な水滴の形状を描画
            drawRealisticDroplet(ctx, x, y, radius, shape, alpha, color) {
                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                
                // 基本的な楕円形状から開始
                ctx.save();
                ctx.translate(x, y);
                
                // 形状の歪みを適用
                ctx.scale(shape.distortionX, shape.distortionY);
                
                // 非対称性を追加
                if (shape.asymmetry !== 0) {
                    ctx.transform(1, 0, shape.asymmetry, 1, 0, 0);
                }
                
                ctx.beginPath();
                
                if (this.velocity > 1) {
                    // 高速移動時：ティアドロップ形状
                    this.drawTearDrop(ctx, radius);
                } else {
                    // 低速または静止時：変形した楕円
                    this.drawDeformedEllipse(ctx, radius, shape.flattenFactor);
                }
                
                ctx.fill();
                ctx.restore();
            }
            
            // ティアドロップ形状を描画
            drawTearDrop(ctx, radius) {
                // より現実的なティアドロップ形状
                ctx.beginPath();
                
                // 上部の尖った部分
                ctx.moveTo(0, -radius * 0.7);
                ctx.quadraticCurveTo(-radius * 0.4, -radius * 0.2, -radius * 0.6, radius * 0.1);
                ctx.quadraticCurveTo(-radius * 0.3, radius * 0.5, 0, radius * 0.8);
                ctx.quadraticCurveTo(radius * 0.3, radius * 0.5, radius * 0.6, radius * 0.1);
                ctx.quadraticCurveTo(radius * 0.4, -radius * 0.2, 0, -radius * 0.7);
                
                ctx.closePath();
            }
            
            // 変形した楕円を描画
            drawDeformedEllipse(ctx, radius, flattenFactor) {
                // より現実的な不規則楕円
                ctx.beginPath();
                
                let points = [];
                let numPoints = 12;
                
                for (let i = 0; i < numPoints; i++) {
                    let angle = (i / numPoints) * Math.PI * 2;
                    let baseX = Math.cos(angle) * radius;
                    let baseY = Math.sin(angle) * radius * (1 - flattenFactor * 0.4);
                    
                    // 表面張力による微妙な波打ち
                    let surfaceTension = Math.sin(angle * 3) * radius * 0.05;
                    let irregularity = random(0.92, 1.08);
                    
                    let x = baseX * irregularity + surfaceTension;
                    let y = baseY * irregularity;
                    
                    points.push({x, y});
                }
                
                // スムーズな曲線で接続
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 0; i < points.length; i++) {
                    let current = points[i];
                    let next = points[(i + 1) % points.length];
                    let controlX = current.x + (next.x - current.x) * 0.5;
                    let controlY = current.y + (next.y - current.y) * 0.5;
                    ctx.quadraticCurveTo(current.x, current.y, controlX, controlY);
                }
                
                ctx.closePath();
            }

            display() {
                // トレイルの描画（より透明な白色で、グラデーション効果）
                for (let i = 0; i < this.trail.length; i++) {
                    let alpha = map(i, 0, this.trail.length - 1, 0, this.opacity * 0.25);
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.trail[i].x, this.trail[i].y, this.trail[i].r, 0, Math.PI * 2);
                    ctx.fill();
                }

                // 水滴の影（現実的な形状で）
                let shadowShape = {
                    distortionX: this.shape.distortionX * 0.9,
                    distortionY: this.shape.distortionY * 0.95,
                    asymmetry: this.shape.asymmetry,
                    flattenFactor: this.shape.flattenFactor
                };
                this.drawRealisticDroplet(
                    ctx, 
                    this.x + this.radius * 0.15, 
                    this.y + this.radius * 0.15, 
                    this.radius * 0.9, 
                    shadowShape,
                    this.opacity * 0.08, 
                    'rgba(0, 0, 0, 0.1)'
                );
                
                // 水滴の外側の輪郭（より透明で大きめ）
                let outerShape = {
                    distortionX: this.shape.distortionX * 1.05,
                    distortionY: this.shape.distortionY * 1.03,
                    asymmetry: this.shape.asymmetry * 0.8,
                    flattenFactor: this.shape.flattenFactor * 0.7
                };
                this.drawRealisticDroplet(
                    ctx, 
                    this.x, 
                    this.y, 
                    this.radius * 1.1, 
                    outerShape,
                    this.opacity * 0.15, 
                    `rgba(255, 255, 255, ${this.opacity * 0.15})`
                );
                
                // メインの水滴（現実的な形状）
                this.drawRealisticDroplet(
                    ctx, 
                    this.x, 
                    this.y, 
                    this.radius, 
                    this.shape,
                    this.opacity * 0.35, 
                    `rgba(255, 255, 255, ${this.opacity * 0.35})`
                );
                
                // 水滴の縁（現実的な形状の輪郭）
                ctx.globalAlpha = this.opacity * 0.5;
                ctx.strokeStyle = `rgba(255, 255, 255, ${this.opacity * 0.5})`;
                ctx.lineWidth = 0.5;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.scale(this.shape.distortionX, this.shape.distortionY);
                if (this.shape.asymmetry !== 0) {
                    ctx.transform(1, 0, this.shape.asymmetry, 1, 0, 0);
                }
                ctx.beginPath();
                if (this.velocity > 1) {
                    this.drawTearDrop(ctx, this.radius);
                } else {
                    this.drawDeformedEllipse(ctx, this.radius, this.shape.flattenFactor);
                }
                ctx.stroke();
                ctx.restore();
                
                // 内側のハイライト（位置を形状に合わせて調整）
                ctx.globalAlpha = this.opacity * 0.85;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                let highlightX = this.x - this.radius * 0.35 * this.shape.distortionX;
                let highlightY = this.y - this.radius * 0.35 * this.shape.distortionY;
                ctx.arc(highlightX, highlightY, this.radius * 0.18, 0, Math.PI * 2);
                ctx.fill();
                
                // 追加の小さなハイライト（より現実的な反射効果）
                if (this.radius > 4) {
                    ctx.globalAlpha = this.opacity * 0.6;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.beginPath();
                    let highlight2X = this.x + this.radius * 0.2 * this.shape.distortionX;
                    let highlight2Y = this.y - this.radius * 0.1 * this.shape.distortionY;
                    ctx.arc(highlight2X, highlight2Y, this.radius * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
            }

            collidesWith(other) {
                let distance = dist(this.x, this.y, other.x, other.y);
                return distance < (this.radius + other.radius);
            }

            merge(other) {
                let newRadius = Math.sqrt(this.radius * this.radius + other.radius * other.radius);
                this.radius = newRadius;
                this.x = (this.x * this.radius + other.x * other.radius) / (this.radius + other.radius);
                this.velocity = (this.velocity + other.velocity) * 0.8;
                this.opacity = Math.min(0.9, (this.opacity + other.opacity) / 2);
                other.merged = true;
            }

            isOffScreen() {
                return this.y > canvas.height + this.radius;
            }
        }

        function setup() {
            canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            document.body.appendChild(canvas);
            ctx = canvas.getContext('2d');
            
            // 初期の水滴を生成
            for (let i = 0; i < 15; i++) {
                drops.push(new Droplet(random(canvas.width), random(-50, -10)));
            }
            
            // イベントリスナー
            canvas.addEventListener('click', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                drops.push(new Droplet(x, y, random(5, 15)));
            });
            
            document.addEventListener('keydown', function(e) {
                if (e.key === 'r' || e.key === 'R') {
                    drops = [];
                    trailResidues = [];
                }
            });
            
            window.addEventListener('resize', function() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
            
            draw();
        }

        function draw() {
            // 背景をクリア（透明な窓ガラス効果）
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(220, 240, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 雨粒を時々追加
            if (Math.random() < 0.1 && drops.length < maxDrops) {
                drops.push(new Droplet(random(canvas.width), random(-50, -10)));
            }

            // 軌跡の残留物の更新と描画
            for (let i = trailResidues.length - 1; i >= 0; i--) {
                let residue = trailResidues[i];
                residue.update();
                residue.display();
                
                if (residue.isDead()) {
                    trailResidues.splice(i, 1);
                }
            }

            // 水滴の更新と描画
            for (let i = drops.length - 1; i >= 0; i--) {
                let drop = drops[i];
                
                if (!drop.merged) {
                    drop.update();
                    drop.display();
                    
                    // 他の水滴との衝突チェック
                    for (let j = i - 1; j >= 0; j--) {
                        let other = drops[j];
                        if (!other.merged && drop.collidesWith(other)) {
                            if (drop.radius >= other.radius) {
                                drop.merge(other);
                            } else {
                                other.merge(drop);
                            }
                        }
                    }
                }
                
                // 画面外または合体済みの水滴を削除
                if (drop.isOffScreen() || drop.merged) {
                    drops.splice(i, 1);
                }
            }

            // 窓の縁のエフェクト
            drawWindowEdges();
            
            animationId = requestAnimationFrame(draw);
        }

        function drawWindowEdges() {
            // 窓枠の影
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
            
            // コーナーの水滴集積エフェクト（より透明な白色で）
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            const corners = [
                {x: 0, y: 0},
                {x: canvas.width, y: 0},
                {x: 0, y: canvas.height},
                {x: canvas.width, y: canvas.height}
            ];
            
            corners.forEach(corner => {
                for (let i = 0; i < 3; i++) {
                    let offset = i * 5;
                    let x = corner.x + random(-offset, offset);
                    let y = corner.y + random(-offset, offset);
                    ctx.globalAlpha = random(0.1, 0.3);
                    ctx.beginPath();
                    ctx.arc(x, y, random(2, 6), 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            ctx.globalAlpha = 1;
        }

        // 初期化
        document.addEventListener('DOMContentLoaded', setup);
    </script>
</body>
</html>